[
  {
    "objectID": "homework/shell.html#why-the-unix-shell",
    "href": "homework/shell.html#why-the-unix-shell",
    "title": "Intro to the Unix Shell",
    "section": "1 Why the Unix shell?",
    "text": "1 Why the Unix shell?\nMany of the things you typically do by pointing and clicking can alternatively be done by typing commands. The Unix shell allows you to interact with computers via commands.\nHere are some reasons why you may want to use this seemingly archaic technique:\n\nWorking efficiently with large files\nMaking it easier to repeat (& automate) similar tasks across files, samples, and projects\nAchieving better reproducibility in research\nAt least in bioinformatics, being able to use access the largest and most recent set of approaches and all their options — many graphical user interface programs lag behind in functionality and may cost money as well.\nWorking effectively on a remote supercomputer like the Ohio Supercomputer Center (OSC)\n\n\n\n\n\n\n\nSide note: Some Unix shell terminology (Click to expand)\n\n\n\n\n\nHere are a few interrelated terms you’re likely to run across:\n\nCommand Line — the most general term, an interface1 where you type commands\nTerminal — the program/app/window that can run a Unix shell\nShell — a command line interface to your computer\nUnix Shell — the types of shells on Unix family (Linux + Mac) computers\nBash — the specific Unix shell language that is most common on Unix computers\n\nWhile you’ve seen that these are not all synonyms, in day-to-day computing/bioinformatics, they are often used interchangeably."
  },
  {
    "objectID": "homework/shell.html#how-to-go-through-this-page",
    "href": "homework/shell.html#how-to-go-through-this-page",
    "title": "Intro to the Unix Shell",
    "section": "2 How to go through this page",
    "text": "2 How to go through this page\nYou will be using a Unix shell at the Ohio Supercomputer Center (OSC) — see the instructions below to open one.\nPlease follow along actively by typing all the commands shown below (unless it explicitly says you shouldn’t run something), not just the exercises.\n\nOpening a Unix shell at OSC\n\nLog in to OSC’s OnDemand portal at https://ondemand.osc.edu.\nIn the blue top bar, click on the “Clusters” dropdown menu and then click Pitzer Shell Access.\nA Unix shell will open in a new browser tab (see screenshot below). You’re ready to go!\n\n\n\n\n\n\n\n\n\nCopying and pasting in this shell\n\n\n\nYou can’t right-click in this shell, so to copy-and-paste:\n\nCopy simply by selecting text (you should see a  icon appear).\nPaste using Ctrl+V.\n\n Try copying and pasting a random word into your shell. This may just work, you may get a permission pop-up, or it may silently fail — if the latter, click on the clipboard icon in your browser’s address bar (see red circle in screenshot below):"
  },
  {
    "objectID": "homework/shell.html#the-basics",
    "href": "homework/shell.html#the-basics",
    "title": "Intro to the Unix Shell",
    "section": "3 The basics",
    "text": "3 The basics\n\n3.1 The prompt\nInside your terminal, the “prompt” indicates that the shell is ready for a command. What is shown exactly varies across shells and can also be customized, but our prompts at OSC should show the following information:\n&lt;username&gt;@&lt;node-name&gt; &lt;working-dir&gt;]$\nFor example:\n[jelmer@p0080 jelmer]$ \nWe type our commands after the dollar sign, and then press Enter to execute the command. When the command has finished executing, we’ll get our prompt back and can type a new command.\n\n\n\n3.2 A few simple commands: date, whoami, pwd\nThe Unix shell comes with hundreds of “commands”: small programs that perform specific actions. If you’re familiar with R or Python, a Unix command is like an R/Python function.\nLet’s start with a few simple commands:\n\nThe date command prints the current date and time:\n\ndate\nWed Feb 7 09:11:51 EST 2024\n\nThe whoami (who-am-i) command prints your username:\n\nwhoami\njelmer\n\nThe pwd (Print Working Directory) command prints the path to the directory you are currently located in:\n\npwd\n/users/PAS0471/jelmer\n# [Yours will be different! You are in your Home directory.]\nAll 3 of those commands provided us with some output. That output was printed to screen, which is the default behavior for nearly every Unix command.\n\n\n\n\n\n\nWorking directory and paths (we’ll talk more about paths later)\n\n\n\n\nWhen working in a Unix shell, you are always “in” a specific directory: your working directory (“working dir” for short).\nIn a path (= location of a file or directory) such as that output by pwd, directories are separated by forward slashes /.\n\n\n\n\n\n\n\n\n\nCase and spaces\n\n\n\n\nEverything in the shell is case-sensitive, including commands and file names.\nAvoid spaces in file and directory names!2 Use e.g. underscores to distinguish words (my_long_filename).\n\n\n\n\n\n\n3.3 cd and command actions & arguments\nIn the above three command line expressions:\n\nWe merely typed a command and nothing else\nThe command provided some information, which was printed to screen\n\nBut many commands perform an action other than providing information. For example, you can use the command cd to Change Directory (i.e. change your working dir). And like many commands that perform an action, cd normally has no output at all.\nLet’s use cd to move to another directory by specifying the path to that directory after the cd command:\ncd /fs/ess/PAS2714\npwd\n/fs/ess/PAS2714\nIn more abstract terms, what we did above was to provide cd with an argument, namely the path of the dir to move to. Arguments generally tell commands what file(s) or directory/ies to operate on.\nAs we’ve seen, then, cd gives no output when it successfully changed the working directory. But let’s also see what happens when it does not succeed — it gives an error:\ncd /fs/ess/PAs2714\nbash: cd: /fs/ess/PAs2714: No such file or directory\n\n\nWhat was the problem with the path we specified? (Click to see the answer)\n\nWe used lowercase in /PAs2714/ — this should have been /PAS2714/.\nAs pointed out above, everything, including paths, is case-sensitive in the Unix shell!\n\n\n\n\n3.4 ls and command options\n\nThe default behavior of ls\nThe ls command, short for “list”, will list files and directories:\nls\nshare   users\n(You should still be in /fs/ess/PAS2714. If not, cd there first.)\n\n\n\n\n\n\nSide note: ls output colors (click to expand)\n\n\n\n\n\nThe ls output above does not show the different colors you should see in your shell — the most common ones are:\n\nEntries in blue are directories (like data and metadata above)\nEntries in black are regular files (like README.md above)\nEntries in red are compressed files (we’ll see an example soon).\n\n\n\n\nBy default, ls will list files and dirs in your current working dir, and in the way shown above. For which dir ls lists files and dirs can be changed with arguments, and how ls shows the output can be changed with options.\n\n\n\nOptions\nIn general, whereas arguments tell a command what to operate on, options will modify its behavior. For example, we can call ls with the option -l (a dash followed by a lowercase L):\nls -l \ntotal 1\ndrwxrwx---+ 4 jelmer PAS2714 4096 Mar  1 11:25 share\ndrwxrwx---+ 2 jelmer PAS2714 4096 Mar  1 15:51 users\nNotice that it lists the same items as above, but printed in a different format: one item per line, with additional information such as the date and time each file was last modified, and file sizes in bytes (to the left of the date).\nLet’s add another option, -h:\nls -l -h\ntotal 1.0K\ndrwxrwx---+ 4 jelmer PAS2714 4.0K Mar  1 11:25 share\ndrwxrwx---+ 2 jelmer PAS2714 4.0K Mar  1 15:51 users\n\n\nWhat is different about the output, and what do you think that means? (Click to see the answer)\n\nThe only difference is in the format of the column reporting the sizes of the items listed.\nWe now have “Human-readable filesizes” (hence -h), where sizes on the scale of kilobytes will be shown with Ks, of megabytes with Ms, and of gigabytes with Gs. That can be really useful especially for very large files.\n\nConveniently, options can be “pasted together” as follows:\nls -lh\n\n\n\nArguments\nArguments to ls should be dirs or files to operate on. For example, if we wanted to see what’s inside the share dir, instead of inside our working dir, we could type3:\nls share\ndata  README.md  results\n\n\nIntermezzo: cat and a quick intro to the data\nTo find out what data is contained in this dir, let’s take a look at the README.md file.\nThere are several commands to view the contents of files — the simplest is cat, which will print the entire contents of a file to screen:\ncat share/README.md\nThis 16S amplicon metabarcoding data set compares soil bacterial populations\nunder two different rotational schemes (corn-soy) vs (corn-soy-wheat) at\ntwo research farms in Ohio (Northwest Agricultural Research Station(NW) and Western Agricultural Research Station (W)).\nThere are 32 plots (Ex: 102A) in four blocks (100-400).\nPlots were split into A and BC plots to include a cover crop treatment.\nThis is some information about the data set we will work with during the workshop.\n\n\nLet’s dig a little deeper and check the share/data dir:\nls share/data\nfastq  meta  ref\nThe data dir appears to contain three (sub)dirs with different kinds of data. We’ll talk in detail about that later, but for now let’s look inside the fastq dir:\nls data/fastq\nNW102AB_R1.fastq.gz  NW201C_R1.fastq.gz   NW305AB_R1.fastq.gz  NW404BC_R1.fastq.gz  W204A_R1.fastq.gz   W303C_R1.fastq.gz   W404A_R1.fastq.gz\nNW102AB_R2.fastq.gz  NW201C_R2.fastq.gz   NW305AB_R2.fastq.gz  NW404BC_R2.fastq.gz  W204A_R2.fastq.gz   W303C_R2.fastq.gz   W404A_R2.fastq.gz\nNW102C_R1.fastq.gz   NW203A_R1.fastq.gz   NW305C_R1.fastq.gz   W101AB_R1.fastq.gz   W204BC_R1.fastq.gz  W304AB_R1.fastq.gz  W404BC_R1.fastq.gz\nNW102C_R2.fastq.gz   NW203A_R2.fastq.gz   NW305C_R2.fastq.gz   W101AB_R2.fastq.gz   W204BC_R2.fastq.gz  W304AB_R2.fastq.gz  W404BC_R2.fastq.gz\nNW103AB_R1.fastq.gz  NW203BC_R1.fastq.gz  NW403A_R1.fastq.gz   W101C_R1.fastq.gz    W205A_R1.fastq.gz   W304C_R1.fastq.gz\nNW103AB_R2.fastq.gz  NW203BC_R2.fastq.gz  NW403A_R2.fastq.gz   W101C_R2.fastq.gz    W205A_R2.fastq.gz   W304C_R2.fastq.gz\nNW103C_R1.fastq.gz   NW304A_R1.fastq.gz   NW403BC_R1.fastq.gz  W103AB_R1.fastq.gz   W205BC_R1.fastq.gz  W403AB_R1.fastq.gz\nNW103C_R2.fastq.gz   NW304A_R2.fastq.gz   NW403BC_R2.fastq.gz  W103AB_R2.fastq.gz   W205BC_R2.fastq.gz  W403AB_R2.fastq.gz\nNW201AB_R1.fastq.gz  NW304BC_R1.fastq.gz  NW404A_R1.fastq.gz   W103C_R1.fastq.gz    W303AB_R1.fastq.gz  W403C_R1.fastq.gz\nNW201AB_R2.fastq.gz  NW304BC_R2.fastq.gz  NW404A_R2.fastq.gz   W103C_R2.fastq.gz    W303AB_R2.fastq.gz  W403C_R2.fastq.gz\nAh, FASTQ files! These contain our sequence data (the reads from the Illumina sequencer), and we’ll go and explore them in a bit.\n\n\nCombining options and arguments\nWe’ll combine options and arguments to take a closer look at our dir with FASTQ files — now the -h option is especially useful and allows us to see that the FASTQ files are around 2-3 Mb in size:\nls -lh share/data/fastq\ntotal 150M\n-rw-r-----+ 1 jelmer PAS0471 2.0M Mar  1 11:24 NW102AB_R1.fastq.gz\n-rw-r-----+ 1 jelmer PAS0471 2.6M Mar  1 11:24 NW102AB_R2.fastq.gz\n-rw-r-----+ 1 jelmer PAS0471 2.3M Mar  1 11:24 NW102C_R1.fastq.gz\n-rw-r-----+ 1 jelmer PAS0471 3.0M Mar  1 11:24 NW102C_R2.fastq.gz\n-rw-r-----+ 1 jelmer PAS0471 1.9M Mar  1 11:24 NW103AB_R1.fastq.gz\n-rw-r-----+ 1 jelmer PAS0471 2.6M Mar  1 11:24 NW103AB_R2.fastq.gz\n-rw-r-----+ 1 jelmer PAS0471 2.3M Mar  1 11:24 NW103C_R1.fastq.gz\n-rw-r-----+ 1 jelmer PAS0471 3.1M Mar  1 11:24 NW103C_R2.fastq.gz\n-rw-r-----+ 1 jelmer PAS0471 1.9M Mar  1 11:24 NW201AB_R1.fastq.gz\n-rw-r-----+ 1 jelmer PAS0471 2.5M Mar  1 11:24 NW201AB_R2.fastq.gz\n# [...output truncated...]\n\n\n\n\n\n\nWhy so small?\n\n\n\nThe FASTQ files are so small because we’ve “subsampled” them: these only contain 10% of the reads of the original files. This will allow us to do the demonstrational analyses in the workshops more rapidly.\n\n\n\n\n\n Exercise: Listing files\nList the files in the share/data/ref dir:\n\nWhat is the file size?\nDo you know what kind of file this is?\n\n\n\nClick for the solution\n\nls -lh share/data/ref\ntotal 131M\n-rwxr--r-- 1 jelmer PAS2714 131M Feb 27 11:53 silva_nr99_v138.1_train_set.fa.gz\n\nThe file is 131 Mb large.\nThis is a FASTA file with nucleotide sequences (hence the extension .fa), which has been compressed (hence the extension .gz).\n\n\n\n\n\n\n3.5 Miscellaneous tips\n\nCommand history: If you hit the ⇧ (up arrow) once, you’ll retrieve your most recent command, and if you keep hitting it, you’ll go further back. The ⇩ (down arrow) will go the other way: towards the present.\nYour cursor can be anywhere on a line (not just at the end) when you press Enter to execute a command!\nTab completion: file paths can Tab-complete! Try to type a partial path and test it. If you’re not getting it to work, it might be worth Googling this feature and watching a demo video.\nAny text that comes after a # is considered a comment instead of code!\n# This entire line is a comment - you can run it and nothing will happen\npwd    # 'pwd' will be executed but everything after the '#' is ignored\n/fs/ess/PAS2714/data\n\n\n\nIf your prompt is “missing”, the shell is still busy executing your command, or you typed an incomplete command. To abort in either of these scenarios, press Ctrl+C and you will get your prompt back.\nTo simulate a long-running command that we may want to abort, we can use the sleep command, which will make the computer wait for a specified amount of time until giving your prompt back. Run the below command and instead of waiting for the full 60 seconds, press Ctrl + C to get your prompt back sooner!\nsleep 60s\nOr, use Ctrl + C after running this example of an incomplete command (an opening parenthesis ():\n("
  },
  {
    "objectID": "homework/shell.html#paths-and-environment-variables",
    "href": "homework/shell.html#paths-and-environment-variables",
    "title": "Intro to the Unix Shell",
    "section": "4 Paths and environment variables",
    "text": "4 Paths and environment variables\n\n4.1 Paths\n\nAbsolute (full) paths versus relative paths\n\nAbsolute (full) paths (e.g. /fs/ess/PAS2714)\nPaths that begin with a / always start from the computer’s root directory, and are called “absolute paths”.\n(They are equivalent to GPS coordinates for a geographical location, as they work regardless of where you are).\nRelative paths (e.g. data/fastq)\nPaths that instead start from your current working directory are called “relative paths”.\n(These work like directions along the lines of “take the second left:” they depend on your current location.)\n\n# Move into the 'PAS2714' dir with an absolute path:\ncd /fs/ess/PAS2714\n\n# Then, move into the 'share/data' dir with a relative path:\ncd share/data                   # Absolute path is /fs/ess/PAS2714/share/data\n\n\nPath shortcuts\n\n~ (a tilde) — represents your Home directory. For example, cd ~ moves you to your Home dir.\n. (a single period) — represents the current working directory.\n.. (two periods) — Represents the directory “one level up”, i.e. towards the computer’s root dir.\n\nls ..              # One level up, listing /fs/ess/PAS2714/share\ndata  README.md  results\nThis pattern can be continued all the way to the root of the computer, so ../.. means two levels up:\nls ../..            # Two levels up, listing /fs/ess/PAS2714\nshare  users\n\n\n\n\n\n\nThese shortcuts work with all commands\n\n\n\nAll of the above shortcuts (., .., ~) are general shell shortcuts that work with any command that accepts a path/file name.\n\n\n\n\n\n Exercise: Path shortcuts\n\nA) Use relative paths to move up to /fs/ess/PAS2714 and back to share/data once again.\n\n\n\n(Click for the solution)\n\ncd ../..\ncd share/data\n\n\nB) List the files in your Home dir without moving there.\n\n\n\n(Click for the solution)\n\nls ~\n\n\n\n\n\n4.2 Environment variables\nYou are likely familiar with the concept of variables in either the Unix shell, R, or another language.\n\nAssigning and printing the value of a variable in R:\n\n# (Don't run this)\nx &lt;- 5\nx\n\n[1] 5\n\n\nAssigning and printing the value of a variable in the Unix shell:\nx=5\necho $x\n5\n\n\n\n\n\n\n\nIn the Unix shell code above, note that:\n\n\n\n\nThere cannot be any spaces around the = in x=5.\nYou need a $ prefix to reference (but not to assign) variables in the shell4.\nYou need the echo command, a general command to print text, to print the value of $x (cf. in R).\n\nBy the way, echo can also print literal text (as shown below) or combinations of literals and variables (next exercise):\necho \"Welcome to the Unix shell\"\nWelcome to the Unix shell\n\n\n\nEnvironment variables are pre-existing variables that have been assigned values automatically. Two examples:\n# $HOME contains the path to your Home dir:\necho $HOME\n/users/PAS0471/jelmer\n# $USER contains your user name:\necho $USER\njelmer\n\n Exercise: environment variables\nB) Print “Hello there, &lt;your username&gt;” (e.g. “Hello there, marcus”) to the screen:\n\n\nClick to see the solution\n\n# (This would also work without the \" \" quotes)\necho \"Hello there $USER\"\nHello there jelmer"
  },
  {
    "objectID": "homework/shell.html#managing-files-and-dirs",
    "href": "homework/shell.html#managing-files-and-dirs",
    "title": "Intro to the Unix Shell",
    "section": "5 Managing files and dirs",
    "text": "5 Managing files and dirs\n\n5.1 Create dirs with mkdir\nThe mkdir command creates new directories. For example, to create your own dir within /fs/ess/PAS2714:\ncd /fs/ess/PAS2714/users\n\nmkdir $USER\nOr two directories at once:\nmkdir $USER/scripts $USER/sandbox\nLet’s check what we did:\nls $USER\nscripts sandbox\n\n\n\n\n\n\n\nConfused by $USER?\n\n\n\nInstead of $USER, you can also type your literal username. If you do that, make sure that you get your username exactly right, including any capitalization.\nFor example, I (username jelmer) could have run the following commands instead of the ones above:\nmkdir jelmer\n\nmkdir jelmer/scripts jelmer/sandbox\n\nls jelmer\n\n\n\n\n\n\n\n\nSide note: Recursive mkdir (Click to expand)\n\n\n\n\n\nBy default, mkdir does not work recursively: that is, it will refuse to make a dir inside a dir that does not yet exist. And if you try to do so, the resulting error might confuse you:\nmkdir sandbox/2024/02/07\nmkdir: cannot create directory ‘sandbox/2024/02/07’: No such file or directory\n\nWhy won’t you do your job, mkdir!? 😡\n\nInstead, we need to use the -p option to mkdir:\nmkdir -p sandbox/2024/02/07\nThe -p option also changes mkdir’s behavior when you try to create a dir that already exists. Without -p that will result in an error, and with -p it doesn’t complain about that (and it won’t recreate/overwrite the dir either).\n\n\n\n\n\n\n5.2 Copy files and dirs with cp\nAbove, you created your own directory — now, let’s get you a copy of the data we saw in the data dir.\nThe cp command copies files and/or directories from one location to another. It has two required arguments: what you want to copy (the source), and where you want to copy it to (the destination). So, we can summarize its basic syntax as cp &lt;source&gt; &lt;destination&gt;.\nLet’s start by copying a single file twice:\n# You should be in /fs/ess/PAS2714/users/$USER/\n\n# Only provide a dir as the destination =&gt; Don't change the file name:\ncp /fs/ess/PAS2714/sandbox/testfile.txt sandbox/\n\n# Provide a file name as the destination =&gt; Give the copy a new name:\ncp /fs/ess/PAS2714/sandbox/testfile.txt sandbox/testfile_mycopy.txt\n\n# Check the files we created:\nls sandbox\ntestfile_mycopy.txt  testfile.txt\n\ncp is not recursive by default, so if you want to copy a directory and all of its contents, you need to use its -r option. We’ll use that option to copy the dir with FASTQ files:\ncp -rv /fs/ess/PAS2714/share/data /fs/ess/PAS2714/users/$USER/\n‘/fs/ess/PAS2714/share/data’ -&gt; ‘./data’\n‘/fs/ess/PAS2714/share/data/meta’ -&gt; ‘./data/meta’\n‘/fs/ess/PAS2714/share/data/meta/meta.tsv’ -&gt; ‘./data/meta/meta.tsv’\n‘/fs/ess/PAS2714/share/data/ref’ -&gt; ‘./data/ref’\n‘/fs/ess/PAS2714/share/data/ref/silva_nr99_v138.1_train_set.fa.gz’ -&gt; ‘./data/ref/silva_nr99_v138.1_train_set.fa.gz’\n‘/fs/ess/PAS2714/share/data/fastq’ -&gt; ‘./data/fastq’\n‘/fs/ess/PAS2714/share/data/fastq/W404A_R2.fastq.gz’ -&gt; ‘./data/fastq/W404A_R2.fastq.gz’\n‘/fs/ess/PAS2714/share/data/fastq/NW203A_R2.fastq.gz’ -&gt; ‘./data/fastq/NW203A_R2.fastq.gz’\n‘/fs/ess/PAS2714/share/data/fastq/W205BC_R2.fastq.gz’ -&gt; ‘./data/fastq/W205BC_R2.fastq.gz’\n# [...output truncated...]\n\n\n\n\n\n\nAbove we also used the -v option, short for verbose, to make cp tell us what it did\n\n\n\n\n\n\nWe can also get a nice recursive overview of all our files with tree:\ntree -C                 # '-C' for colors, not visible on this site though\n.\n├── data\n│   ├── fastq\n│   │   ├── NW102AB_R1.fastq.gz\n│   │   ├── NW102AB_R2.fastq.gz\n│   │   ├── NW102C_R1.fastq.gz\n│   │   ├── NW102C_R2.fastq.gz\n│   │   ├── NW103AB_R1.fastq.gz\n│   │   ├── NW103AB_R2.fastq.gz\n        ├── [...Other FASTQ files not shown...]\n│   ├── meta\n│   │   └── meta.tsv\n│   └── ref\n│       └── silva_nr99_v138.1_train_set.fa.gz\n├── sandbox\n│   ├── testfile_mycopy.txt\n│   └── testfile.txt\n└── scripts\n\n\n\n5.3 Move with mv, and cp/mv tips\nThe mv command is nearly identical to the cp command, except that it:\n\nMoves rather than copies files and/or dirs\nWorks recursively by default\n\nThere is no separate command for renaming, because both cp and mv allow you to provide a different name for the target.\nLet’s start by moving the testfile.txt into our current working dir:\nmv sandbox/testfile.txt .\nAnd we can move and rename at the same time as well — let’s do that to move testfile.txt back and give it a new name at once:\nmv testfile.txt sandbox/testfile_v2.txt\n\n\n\n\n\n\nOverwriting\n\n\n\nBy default, both mv and cp will overwrite files without warning! Use the -i (forinteractive) option to make it let you confirm before overwriting anything.\n\n\n\n\n\n\n\n\nRenaming rules for both cp and mv — if the destination is:\n\n\n\n\nAn existing dir, the file(s) will keep their original names.\nNot an existing dir, the path specifies the new name of the file or dir, depending on what the source is.\n\n\n\n\nExercise: Practice with mv\nIn which directory (in terms of a relative path from your working dir) would the FASTQ files end up with each of the following commands?\n\nmv data/fastq data/fastq_files\nmv data/fastq fastq\nmv data/fastq .\n\nWhat if you wanted to move the FASTQ files directly into your current working directory (from data/fastq)?\n\n\n\nSolutions (click here)\n\nIn which directory (in terms of relative path from your working dir) will the FASTQ files end up with each of the following commands?\n\nmv data/fastq data/fastq_files — in the dir fastq_files (we’ve really just renamed the dir fastq to fastq_files)\nmv data/fastq fastq — in fastq (because our source is a dir, so is the destination)\nmv data/fastq . — in fastq also! (we’d need the syntax shown below to move the individual files directly into our current dir)\n\nWhat if you wanted to move the FASTQ files directly into your current working directory?\nFor one file:\nmv data/fastq/ASPC1_A178V_R1.fastq.gz .\nFor all files:\nmv data/fastq/* .\n\n\n\n\n\n5.4 Remove files with rm\nThe rm command removes (deletes) files and directories.\nOne important thing to note upfront is that rm will permanently and irreversibly delete files without the typical “intermediate step” of placing them in a trash bin, like you are used to with your personal computer. With a healthy dosis of fear installed, let’s dive in.\nTo remove one or more files, you can simply pass the file names as arguments to rm as with previous commands. We will also use the -v (verbose) option to have it tell us what it did:\nrm -v sandbox/testfile_v2.txt\nremoved sandbox/testfile_v2.txt\n\n\nRecursive rm\nAs a safety measure, rm will by default only delete files and not directories or their contents — i.e., like mkdir and cp, it refuses to act recursively by default. To remove dirs and their contents, use the -r option:\n# First we create 3 levels of dirs - we need `-p` to make mkdir work recursively:\nmkdir -p d1/d2/d3\n\n# Then we try to remove the d1 dir - which fails:\nrm d1\nrm: cannot remove ‘d1’: Is a directory\n# But it does work with the '-r' option:\nrm -rv d1\nremoved directory: ‘d1/d2/d3’\nremoved directory: ‘d1/d2’\nremoved directory: ‘d1’\nYou should obviously be quite careful with rm -r!\n\n\n\n\n\n\nThere is no thrash bin when deleting files in the shell, so use rm with caution! (Click to expand)\n\n\n\n\n\nrm -r can be very dangerous — for example rm -r / would at least attempt to remove the entire contents of the computer, including the operating system.\nA couple ways to take precautions:\n\nYou can add the -i option, which will have you confirm each individual removal (can be tedious)\nWhen you intend to remove an empty dir, you can use the rmdir command which will do just (and only) that — that way, if the dir isn’t empty after all, you’ll get an error."
  },
  {
    "objectID": "homework/shell.html#globbing-and-loops",
    "href": "homework/shell.html#globbing-and-loops",
    "title": "Intro to the Unix Shell",
    "section": "6 Globbing and loops",
    "text": "6 Globbing and loops\n\n6.1 Globbing with shell wildcard expansion\nShell wildcard expansion is a very useful technique to select files. Selecting files with wildcard expansion is called globbing. Wildcards are symbols that have a special meaning.\nIn globbing, the * wildcard matches any number of any character, including nothing.\nThe example below will match any files that contain the string “_R1”:\n# (You should still be in /fs/ess/PAS2714/users/$USER)\nls data/fastq/*_R1*\ndata/fastq/NW102AB_R1.fastq.gz  data/fastq/NW201C_R1.fastq.gz   data/fastq/NW305AB_R1.fastq.gz  data/fastq/NW404BC_R1.fastq.gz  data/fastq/W204A_R1.fastq.gz   data/fastq/W303C_R1.fastq.gz   data/fastq/W404A_R1.fastq.gz\ndata/fastq/NW102C_R1.fastq.gz   data/fastq/NW203A_R1.fastq.gz   data/fastq/NW305C_R1.fastq.gz   data/fastq/W101AB_R1.fastq.gz   data/fastq/W204BC_R1.fastq.gz  data/fastq/W304AB_R1.fastq.gz  data/fastq/W404BC_R1.fastq.gz\ndata/fastq/NW103AB_R1.fastq.gz  data/fastq/NW203BC_R1.fastq.gz  data/fastq/NW403A_R1.fastq.gz   data/fastq/W101C_R1.fastq.gz    data/fastq/W205A_R1.fastq.gz   data/fastq/W304C_R1.fastq.gz\ndata/fastq/NW103C_R1.fastq.gz   data/fastq/NW304A_R1.fastq.gz   data/fastq/NW403BC_R1.fastq.gz  data/fastq/W103AB_R1.fastq.gz   data/fastq/W205BC_R1.fastq.gz  data/fastq/W403AB_R1.fastq.gz\ndata/fastq/NW201AB_R1.fastq.gz  data/fastq/NW304BC_R1.fastq.gz  data/fastq/NW404A_R1.fastq.gz   data/fastq/W103C_R1.fastq.gz    data/fastq/W303AB_R1.fastq.gz  data/fastq/W403C_R1.fastq.gz\nSome more file matching examples with * — if you would be in your data/fastq dir, then:\n\n\n\nPattern\nMatches files whose names…\n\n\n\n\n*\nContain anything (matches all files)\n\n\n*fastq.gz\nEnd in “.fastq.gz”\n\n\nNW1*\nStart with “NW1”\n\n\n*_R1*\nContain “_R1”\n\n\n\n\n\n Exercise: Practice with *\nWhat pattern would you use if you wanted to select FASTQ files for the samples whose IDs end in AB (e.g. NW102AB)?\n\n\nClick here for the solutions\n\nWe’ll need a * on either side of our pattern, because the file names neither start not end with the pattern:\nls data/fastq/*AB_R*\ndata/fastq/NW102AB_R1.fastq.gz  data/fastq/NW103AB_R2.fastq.gz  data/fastq/NW305AB_R1.fastq.gz  data/fastq/W101AB_R2.fastq.gz  data/fastq/W303AB_R1.fastq.gz  data/fastq/W304AB_R2.fastq.gz\ndata/fastq/NW102AB_R2.fastq.gz  data/fastq/NW201AB_R1.fastq.gz  data/fastq/NW305AB_R2.fastq.gz  data/fastq/W103AB_R1.fastq.gz  data/fastq/W303AB_R2.fastq.gz  data/fastq/W403AB_R1.fastq.gz\ndata/fastq/NW103AB_R1.fastq.gz  data/fastq/NW201AB_R2.fastq.gz  data/fastq/W101AB_R1.fastq.gz   data/fastq/W103AB_R2.fastq.gz  data/fastq/W304AB_R1.fastq.gz  data/fastq/W403AB_R2.fastq.gz\n\n\n\n\n\n6.2 For loops\nLoops are a universal element of programming languages, and are used to repeat operations. Here, we’ll only cover the most common type of loop: the for loop.\nA for loop iterates over a collection, such as a list of files, and allows you to perform one or more actions for each element in the collection. In the example below, our “collection” is just a short list of numbers (1, 2, and 3):\n\nfor a_number in 1 2 3; do\n    echo \"In this iteration of the loop, the number is $a_number\"\n    echo \"--------\"\ndone\n\nIn this iteration of the loop, the number is 1\n--------\nIn this iteration of the loop, the number is 2\n--------\nIn this iteration of the loop, the number is 3\n--------\n\n\nThe indented lines between do and done contain the code that is being executed as many times as there are items in the collection: in this case 3 times, as you can tell from the output above.\n\n\n\n\n\n\nWhat was actually run under the hood is the following:\n\n\n\n# (Don't run this)\na_number=1\necho \"In this iteration of the loop, the number is $a_number\"\necho \"--------\"\n\na_number=2\necho \"In this iteration of the loop, the number is $a_number\"\necho \"--------\"\n\na_number=3\necho \"In this iteration of the loop, the number is $a_number\"\necho \"--------\"\n\n\n\nCombining loops and globbing\nA very useful strategy is to loop over files with globbing, for example:\nfor fastq_file in data/fastq/*fastq.gz; do\n    echo \"Running an analysis for file $fastq_file\"...\n    # Additional commands to process the FASTQ file\ndone\nRunning an analysis for file data/fastq/NW102AB_R1.fastq.gz...\nRunning an analysis for file data/fastq/NW102AB_R2.fastq.gz...\nRunning an analysis for file data/fastq/NW102C_R1.fastq.gz...\nRunning an analysis for file data/fastq/NW102C_R2.fastq.gz...\nRunning an analysis for file data/fastq/NW103AB_R1.fastq.gz...\nRunning an analysis for file data/fastq/NW103AB_R2.fastq.gz...\nRunning an analysis for file data/fastq/NW103C_R1.fastq.gz...\n#[...output truncated...]\n\n\n\n\n\n\nA further explanation of for loop syntax (Click to expand)\n\n\n\n\n\nOn the first and last, unindented lines, for loops contain the following mandatory keywords:\n\n\n\n\n\n\n\nKeyword\nPurpose\n\n\n\n\nfor\nAfter for, we set the variable name (an arbitrary name; above we used a_number)\n\n\nin\nAfter in, we specify the collection (list of items) we are looping over\n\n\ndo\nAfter do, we have one ore more lines specifying what to do with each item\n\n\ndone\nTells the shell we are done with the loop\n\n\n\n\n\n\n\n\n Exercise: A simple loop\nCreate a loop that will print:\nmorel is an Ohio mushroom  \ndestroying_angel is an Ohio mushroom  \neyelash_cup is an Ohio mushroom\n\n\nClick for the solution\n\nfor mushroom in morel destroying_angel eyelash_cup; do\n    echo \"$mushroom is an Ohio mushroom\"\ndone\nmorel is an Ohio mushroom  \ndestroying_angel is an Ohio mushroom  \neyelash_cup is an Ohio mushroom"
  },
  {
    "objectID": "homework/shell.html#footnotes",
    "href": "homework/shell.html#footnotes",
    "title": "Intro to the Unix Shell",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nCommand-line Interface (CLI), as opposed to Graphical User Interface (GUI)↩︎\nIt’s certainly possible to have spaces in file names, but it’s a bad idea, and will get you into trouble sooner or later.↩︎\nBeginners will often cd into a dir just to list its contents, but the method shown below is much quicker.↩︎\nAnytime you see a word/string that starts with a $ in the shell, you can safely assume that it is a variable.↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Amplicon Metabarcoding Workshop",
    "section": "",
    "text": "Day\nTime\nTopic\nBy\n\n\n\n\nWed\n1 - 2 pm\nLecture: Introduction to Metabarcoding\nTim\n\n\n\n2:15 - 3 pm\nLab: Intro to OSC\nJelmer\n\n\n\n3 - 4:30 pm\nLab: QC & trimming\nJelmer\n\n\nThu\n1 - 2 pm\nLecture: ASV/OTU calling and pipeline considerations\nSoledad\n\n\n\n2:15 - 3:15 pm\nLab: Calling ASVs with the DADA2 pipeline\nTim\n\n\n\n3:30 - 4:30 pm\nLab: Alpha & Beta diversity\nTim\n\n\nFri\n1 - 2 pm\nLab: Differential abundance with DESeq2\nMelanie\n\n\n\n2 - 3 pm\nLab: Network analysis\nMelanie\n\n\n\n3 - 4 pm\nLab: Core microbiome analysis\nFiama\n\n\n\n4 - 4:30 pm\nLab: Metadata and data submission to databases\nSoledad\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is the website for an Ohio State University workshop on Amplicon Metabarcoding, held from March 13-15, 2024 in Wooster, Ohio.\nThis workshop is co-organized by:\n\nDr. Soledad Benitez-Ponce, Dept. of Plant Pathology\nDr. Timothy Frey, Dept. of Plant Pathology\nDr. Jelmer Poelstra, Molecular and Cellular Imaging Center (MCIC)\nFiama Guevara, Dept. of Plant Pathology\nMelanie Medina Lopez, Dept. of Plant Pathology\n\n\n\n\n Back to top"
  }
]