---
title: "Homework: Intro to R"
author: Jelmer Poelstra
date: 2024-03-04
editor: source
execute: 
  eval: true
  cache: true
knitr:
  opts_chunk:
    out.width: "85%"
    class-output: styled-output
number-depth: 3
project:
  execute-dir: project
editor_options: 
  chunk_output_type: console
---

------------

<br>

## Why R?

R is a versatile, open source programming/scripting language that's particularly
useful for *statistics* and *data visualization*.

**Yes, there is a learning curve, and many of us just want to get on with our analysis --    
but investing in learning R will pay off:**

- R gives you greater **flexibility** to do anything you want.
- A greater **reproducibility** of scripting vs clicking.
- R is highly **interdisciplinary** -- e.g. very useful for analyzing sequencing data
  but can also be used to create maps and perform GIS analyses, and so on!
- R is more than a platform to perform analysis.
  Combined with *Markdown* (a simple text markup language),
  you can use R to produce sophisticated reports, and create slide decks and websites such as this one!

Furthermore, R:

- Is freely available on all platforms, and open source.
- Has a large and welcoming user community.

<hr style="height:1pt; visibility:hidden;" />

### Learning Objectives {-}

- Get some basic familiarity with R and RStudio
- Learn why and how to use RStudio Projects
- Understand objects, functions, and how to use them
- Understand the concepts of `vector` and `data.frame`
- Explore the structure and the content of a `data.frame`
- Learn to subset/slice vectors and data frames
- Learn about how R handles missing data

-----

<br>

## Getting set up

### Start an RStudio session at OSC

1.  Log in to OSC at <https://ondemand.osc.edu>.

2.  Click on **`Interactive Apps`** (top bar) and then **`RStudio Server`** (all the way at the bottom).

3.  Fill out the form as follows:

    -   Cluster: **`Pitzer`**
    -   R version: **`4.3.0`**
    -   Project: **`PAS2714`**
    -   Number of hours: **`4`**
    -   Node type: **`any`**
    -   Number of cores: **`1`**

<details><summary>*Click to see a screenshot*</summary>

![](img/rstudio_form.png){fig-align="center" width="50%"}

</details>

4.  Click the big blue **`Launch`** button at the bottom

5.  Now, you should be sent to a new page with a box at the top for your RStudio Server
    "job", which should initially be "Queued" (waiting to start).

<details><summary>*Click to see a screenshot*</summary>

![](img/rstudio_queued.png){fig-align="center" width="70%"}

</details>

6.  Your job should start running very soon, with the top bar of the box turning green and saying "Running".

<details><summary>*Click to see a screenshot*</summary>

![](img/rstudio_running.png){fig-align="center" width="70%"}

</details>

7.  Click **`Connect to RStudio Server`** at the bottom of the box,
    and an RStudio Server instance will open in a new browser tab. You're ready to go!

<hr style="height:1pt; visibility:hidden;" />

### R vs. RStudio

**R** simply provides a "*console*" to type your commands.
However, because we want to save our commands in scripts,
examine output such a graphics, and so on,
we would like an environment that provides all of this side-by-side.

We will use **RStudio**, an excellent "Integrated Development Environment" (IDE) for R.
In RStudio, we have a *single interface* to write code, navigate files on our computer,
inspect the objects we create, and visualize plots.

RStudio is divided into 4 "panes"^[The placement of these panes and their content can be customized.]:

- **_Top-left_**: The **editor** for your scripts and documents.
- **_Bottom-left_**: The **R console**.
- **_Top-right_**: Your environment/history.
- **_Bottom-left_**: Your files/plots/packages/help/viewer.
  
![The RStudio pane layout](img/rstudio-layout.png){fig-align="center" width="80%"}

<br>

## Interacting with R

### R as a calculator

The lower-left RStudio pane, i.e. **the R console**,
is where you can interact with R directly.
The **`>`** sign is the R "prompt".
It indicates that R is ready for you to type something.

Let's start by performing a division:

```{r add, eval=TRUE, results='show'}
203 / 2.54
```

R does the calculation and prints the result, and then you get the `>` prompt again.
(The `[1]` may look a bit weird when there is only one output element; 
this is how you can keep count of output elements.)

With the standard symbols you can use R as a general calculator:

```{r calculations, eval = TRUE, results='show'}
203 * 2.54   # Multiplication
203 + 2.54   # Addition
```

<hr style="height:1pt; visibility:hidden;" />

### Trying some random things...

```{r space, eval=TRUE, results="show"}
   203     - 2.54
```

This works: so R just ignores any extra spaces.
How about:

```{r hanging_prompt, eval=FALSE}
203 +
```

<details><summary>{{< fa user-edit >}} Now the prompt is a `+`. What is going on? _(Click for the answer)_</summary>

R is waiting for you to finish the command, since you typed an incomplete command:
something has to come after the `+` to be added to what came before.

While it was obvious here, you will often type incomplete commands without
realizing you did so.
Just remember that when you see the `+` prompt,
you are missing something in your command:
often, you'll have forgotten a closing parenthesis `)`
or you accidentally opened up an unwanted opening parenthesis `(`.
</details>

**Press the <kbd>Esc</kbd> button to get your prompt back.**

<hr style="height:1pt; visibility:hidden;" />

And if we just type a number:

```{r number, eval=TRUE, results='show'}
203
```

R will print the number back to us!
It turns out that the default, implicit action that R will perform
on anything you type is to print it back to us
(it is calling a function called `print()` under the hood).

<hr style="height:1pt; visibility:hidden;" />

Rather than a number, what if we want R to print back to us some **text**,
which in programming lingo is called a **"character string"**?

```{r gibberish, eval=TRUE, results='show', error=TRUE}
Fantastic
```

<details><summary>{{< fa user-edit >}} What seems to be going wrong here? _(Click for the answer)_</summary>

Whenever you type a character string, R expects to find an "object" with that name.
(Or, if you would use parentheses after the string, like `string()`,
it will expect a function.)

Because no object called `Fantastic` exists, R throws an error.
To refer to a literal string instead, we need to use quotes (see below).

</details>

<hr style="height:1pt; visibility:hidden;" />

We *can* get R to print character strings back to us,
and work with them in other ways, as long as we quote the strings:

```{r}
"Fantastic"
```

```{r}
"I'm really liking R so far."
```

So, R treats numbers and character strings differently:
**unlike numbers, character strings need to be quoted**.
This _avoids confusion with objects_ (we'll learn about those in a minute)
because unquoted character strings are assumed to be objects,
and also _allows for "special characters" like spaces_.

::: callout-tip
## Quote types
Double quotes (`"Fantastic"`) and single quotes (`'Fantastic'`) can be used interchangeably in R. Double quotes are preferred by most "style guides".
:::

<br>

## Getting Organized

### Need for Scripts and RStudio Projects

We can go along like this, typing commands directly into the R console.
But to better keep track of what you're doing,
it's a good idea to write your code in files, i.e. "**scripts**".
And when we start creating scripts, we need to worry about how we
organize the scripts and data for a project.

It is good practice to keep a set of related data, analyses, and text
self-contained in a single folder,
and use that folder as the **working directory** --- in the Unix shell and in R alike.
RStudio provides a helpful way to
_keep your working directory constant_ through its **"Projects"**.
When you use a Project,
your working directory will be the top-level directory of that project.

<hr style="height:1pt; visibility:hidden;" />

### Create a new RStudio Project

To create a new RStudio Project inside your personal dir in `/fs/ess/PAS2714/users`
(e.g., for me, the dir `/fs/ess/PAS2714/users/jelmer`)

::: {.callout-warning collapse="true"}
### Don't have a personal dir there? _(Click to expand)_
If you followed the [shell homework](shell.qmd),
you should have created your own dir within `/fs/ess/PAS2714/users`.

If you don't have one, you can quickly create it as follows:

```{r, eval=FALSE}
dir.create(paste0("/fs/ess/PAS2714/users/", Sys.getenv("USER")))
```

:::

1.  Click **`File`** (top bar, below your browser's address bar) \> **`New Project`**
2.  In the popup window, click **`Existing Directory`**.

<details><summary>*Click to see a screenshot*</summary>

![](img/rstudio_proj_existingdir.png){fig-align="center" width="40%"}

</details>

3.  Click **`Browse...`** to select your personal dir.

<details><summary>*Click to see a screenshot*</summary>

![](img/rstudio_proj_browse.png){fig-align="center" width="40%"}

</details>

4.  In the next window, you should be in your Home directory (abbreviated as **`~`**),
    from which you can't click your way to `/fs/ess`!
    Instead, you'll first have to click on the (very small!) **`...`** highlighted in the screenshot below:

![](img/rstudio_proj_dotdotdot_ed.png){fig-align="center" width="50%"}

5.  Type at least part of the path to your personal dir in `/fs/ess/PAS2714/users`,
    e.g. like shown below, and click **`OK`**:

![](img/rstudio_proj_path2.png){fig-align="center" width="35%"}

6.  Now you should be able to browse/click the rest of the way to your personal directory,
    something like `/fs/ess/PAS2714/users/jelmer`.
7.  Click **`Choose`** to pick your selected directory.
8.  Click **`Create Project`**.

RStudio should reload and you should now have your new Project "open".
Your working directory should be the Project's directory.
We can check this using `getwd()`:

```{r,eval=FALSE}
getwd()
```
```bash-out
/fs/ess/PAS2714/users/jelmer
```

From now on, we will not change our working directory,
and refer to all files relative to our project's top-level directory.

<hr style="height:1pt; visibility:hidden;" />

### Create an R script

- Create a new R script (`File` > `New File` > `R Script`)
- Click `File` > `Save As` to save the script in the `scripts` dir that you
  should see within your personal dir.^[You created this in the shell introduction. If you don't have it, create it now.]
  Give it a descriptive name like `intro-to-R.R`.

From now on, *type your commands into this script* and execute the commands from there.

To send code from your script to the console, **press <kbd>`Ctrl/Cmd`</kbd> + <kbd>`Enter`</kbd>**.
This will copy the line of code that your cursor is at to the R console and execute it,
and then the cursor will move to the next line.

<hr style="height:1pt; visibility:hidden;" />

### Commenting

You can use **`#` signs** to comment your code:

```{r, eval=FALSE}
# Divide by 2.54 to get the wingspan in inches:
203 / 2.54    # Original measurement was in cm
```

-   Anything to the right of a `#` is ignored by R, meaning it won't be executed
-   You can use `#` both **at the start of a line** (entire line is a comment) or anywhere in a line **following code** (rest of the line is a comment)
-   In your R script, comments are formatted differently so you can clearly distinguish them from code

We recommend that you **use lots of comments in your R scripts**! They are useful not only for others that you may share your code with, but also for yourself when you look back at your code a day, a month, or a year later.

<br>

## R objects

### Assigning stuff to objects

We can assign pretty much anything to an object with the assignment
operator, `<-`^[In RStudio, typing <kbd>Alt</kbd> + <kbd>-</kbd> will write ` <- ` in
a single keystroke. You can also use `=` as assignment, but that symbol can have other
meanings, and so I recommend sticking with the `<-` combination.].
(This is a smaller-than sign `<` followed by a dash `-`.)

A few examples:

```{r assign, eval=TRUE}
wingspan_cm <- 203
conversion <- 2.54
```

Type that into your script, and use <kbd>Ctrl/Cmd</kbd> + <kbd>Enter</kbd> twice to send it to the console.

::: callout-tip
## The Environment tab
The objects you create get added to your "environment",
which RStudio shows in the **Environment tab** in the top-right panel —
check that `wingspan_cm` and `conversion` are indeed there.
:::

After you've assigned a number to an object, you can use it in calculations like so:

```{r sqrt, eval=TRUE, results='show'}
wingspan_cm / conversion
```

Or, similarly:

```{r}
wingspan_inch <- wingspan_cm / conversion
wingspan_inch
```

This illustrates that when you execute code with objects, R substitutes the object name that you provide by its contents under the hood. In other words, *the object is just a reference to the underlying value(s)*.

### Object names

Objects can be given almost any name such as `x`, `current_temperature`, or `subject_id`.
Some pointers on naming:

-   Because R is **case sensitive**, `wingspan_inch` is different from `Wingspan_inch`!
-   An object name **cannot contain spaces** — so for readability, you should *separate words* using:
    -   **Underscores:** `wingspan_inch` (this is called "snake case")
    -   **Periods**: `wingspan.inch`
    -   **Capitalization:** `wingspanInch` or `WingspanInch` ("camel case")
-   You will make things easier for yourself by naming objects in a consistent way, e.g. by sticking to a case type.
-   Object names can *contain* but cannot *start* with a number: `x2` is valid but `2x` is not[^3].
-   Make object names descriptive yet not too long — this is not always easy!

[^3]: There are also some other restrictions that are beyond the scope of this introduction.
For example, there are some names that cannot be used because they are the names of fundamental keywords in R (e.g., `if`, `else`, `for`, see [here](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Reserved.html) for a complete list).
In general, it's also best not to use the names of existing **functions**, even though this *is* possible.

::: exercise
#### {{< fa user-edit >}} Exercises: objects and strings

**A)** Which of the following do you think would work and which would return an error:

```{r}
session_topic <- "introduction"
```

```{r, eval=FALSE}
session_topic <- introduction
```

Try both to see which works and what error you get for the other one. Also, try to describe in words what the correct line of code is doing.

<details><summary><b>Solution</b> (click here)</summary>

The first of the two options was correct R code, while the second returns an error.

In general, keep in mind that **unquoted character strings represent objects**
whereas **quoted character strings are "literals"**.
Here, we wanted to assign the literal string `"introduction"` to the object `session_topic` —
so the former should be quoted and the latter not.

An error is produced when you run the second option,
because the object `introduction` does not exist
(unless, of course, you had created an object of that name!):

```{r, results='show', error=TRUE}
session_topic <- introduction
```

</details>

<hr style="height:1pt; visibility:hidden;" />

**B)** Having run the code above, which of the following would make R print `"introduction"`?

```{r, eval=FALSE}
"session_topic"
```

```{r, eval=FALSE}
session_topic
```

<details><summary><b>Solution</b> (click here)</summary>

The second option is the correct one:
here, we want to have R print the value of the **object `session_topic`**
(which we had just created in exercise A), so we shouldn't use quotes.

```{r}
session_topic
```

</details>

<hr style="height:1pt; visibility:hidden;" />

**C)** Do you think the following code would successfully add `5` and `7`? If not, what might happen instead?

```{r, eval=FALSE}
"5" + "7"
```

<details><summary><b>Solution</b> (click here)</summary>

In the code above, the "numbers" are saved not as numbers (in R lingo: as a `numeric`) but as character strings (`character`).

R can't add character strings, so it will return an error:

```{r eval=TRUE, results='show', error=TRUE}
"5" + "7"
```

(Perhaps you expected it to combine/"concatenate" the two strings in some way — this is in fact what Python would do. Or to automatically convert the characters to numbers, since you're clearly wanting them to be numbers — but it doesn't do that either.)

</details>

<hr style="height:1pt; visibility:hidden;" />

**D) (Bonus)** What is the value of `y` after running the following lines of code?

```{r, eval=FALSE}
x <- 50
y <- x * 2
x <- 80
```

<details><summary>{{< fa user-edit >}} Solution (click here)</summary>

Objects don't get linked to each other, so if you change one,
it won't affect the values of any others.
Therefore, `y` will keep the value `100`.

</details>

:::

<br>

## Functions

Earlier, we divided `203` by `2.54`,
but what if we wanted to round the resulting number?
Like for many things you may want to do in R, there is a **function** for that.

Functions are used by typing their name followed by parentheses:

```{r log, eval=TRUE, results='show'}
round(203 / 2.54)
```

Here, `round()` is a _function_ that rounds a number.
The value in the parentheses is called a function "*argument*",
which is used in the execution of the function.

<hr style="height:1pt; visibility:hidden;" />

### Using named arguments

Functions can have more than one argument, and some of them may have default values.

There are some functions that take many arguments and it can get confusing
trying to keep them in order.
In that case, it is better to explicitly **name the arguments**.

_When you type a function name and pause for a moment_,
the arguments, their names, and their default values
(i.e., the value if the argument is left unspecified) will be shown.

![](img/round_args.png){fig-align="center" width="30%"}

<details><summary>{{< fa user-edit >}} What is the second argument for `round()` and what is its default value? (Click here)</summary>

`round` has a second argument `digits` whose default 
is `0`, such that numbers will be rounded to whole integers.

</details>

Below is an example using named arguments with `round()`.
When the arguments are named, the order doesn't matter!
You might also enter the first few important arguments positionally,
and later ones by naming them.

```{r round_w_named_args}
round(x = 1.538462, digits = 2)

round(digits = 2, x = 1.538462)

round(1.538462, digits = 2)
```

Also here, we can directly plug in objects:

```r
wingspan_in <- 203 / 2.54
round(wingspan_in)
```

Or "nest" functions --- here we are adding the `log()` function to compute the natural log:

```r
log(round(203 / 2.54 ))
```

<details><summary>{{< fa user-edit >}} What is the order of execution in the last command? _(Click for the solution)_</summary>
`round()` is executed first, and the output of `round()` is used as the input of `log()`.
</details>

<br>

## Getting help

As we saw, when we typed `round` and paused for a moment,
we got a pop-up with information about the function.
Alternatively, you could type:

```{r help, eval=FALSE}
?round
```

... and the documentation for the function will show up in the lower-right pane.

This documentation is often a bit _too_ detailed, and can be terse,
so it takes some practice to read.
*Usage*, *Arguments*, and at the bottom, *Examples*, are most useful.

Googling, even if you don't know whether a function exists,
will work too (e.g. "rounding a number in r").

<br>

## Vectors

A **vector** is the most common and basic data structure in R,
and is composed of a **series of values of the same type**^[Technically, a vector
can have a length of 1, so our earlier single numbers were vectors too.].
We can assign a series of values to a vector using the `c()` function
(for "combine"). For example:

```{r, eval = TRUE}
wingspans_cm <- c(11.8, 203, 18.2, 27.9)
```

A vector can also contain characters -- but again, quoting is important,
or R will think the strings are objects:

```{r, eval = TRUE}
birds <- c("hummingbird", "bald_eagle", "chickadee", "cardinal")
```

As mentioned, all of a vector's elements have to be of the same type of data.
The function `class()` indicates what kind of data you are working with:

```{r, eval = TRUE, results='show'}
class(wingspans_cm)
class(birds)
```

<hr style="height:1pt; visibility:hidden;" />

### Data types in R

The classes we saw above are different types of **atomic vectors**,
R's simplest **data type**.
The 4 most common atomic vector types are:

- **`"numeric"`** (or `"double"`) -- floating point numbers (numbers with decimals)
- **`"integer"`** -- integer numbers (no decimals)
- **`"character"`** -- character strings
- **`"logical"`** -- `TRUE` and `FALSE` (also known as boolean)

Also worth mentioning in this context is:

- **`factor`** -- Character strings with a discrete set of possible values,
  used mostly for statistical tests and plotting^[This is technically a type of data structure.].
  
::: {.callout-note collapse="true"}
#### Side note: Vector coercion -- when not all elements are of the same type. _(Click to expand)_

What happens if we try to mix vector types (e.g., "character and numeric")
in a single vector?
**R converts them to all be the same type, and it does so without telling us about it.**
For example:

```{r}
num_char <- c(1, 2, 3, "a")
class(num_char)
```

:::

<hr style="height:1pt; visibility:hidden;" />

### Vectorization!

Let's say we wanted to convert our vector of wingspans to inches:
dividing each length in centimeters by 2.54.
It turns out that this is as easy as dividing the vector by 2.54:

```{r, eval = TRUE, results = "show"}
# wingspans_cm <- c(11.8, 203, 18.2, 27.9)  # Still working with the same wingspans_cm vector

wingspans_in <- wingspans_cm / 2.54
wingspans_in
```

This works because R "*vectorizes*" operations whenever it can.
This means that in this case, each element in the vector `weights_cm` will be divided
by 2.54 -- this number is **recycled** to match the number of weights.
Very useful!

Similarly, we can use two vectors of equal length to quickly operate on each element
of the vector:

```{r eval = TRUE, results =  "show"}
sizes_cm <- c(7.62, 90, 13.1, 21.8)

ratio <- wingspans_cm / sizes_cm
ratio

```

<hr style="height:1pt; visibility:hidden;" />

::: exercise
#### {{< fa user-edit >}} Exercise: Temperature conversion

Recall that you can convert a temperature of, for example, 26 Fahrenheit to Celcius as follows:

```{r}
# (26°F - 32) / 1.8 = -3.3°C
(26 - 32) / 1.8
```

Create and store a vector with the values 26, 21, 24, 32, 33, 41, 51,
representing temperatures in Fahrenheit.

Now convert all the values in this vector from Fahrenheit to Celcius.

<details><summary>Click here for the solution</summary>

Thanks to R's vectorization, you don't have to convert these values 1-by-1:

```{r}
temps_f <- c(26, 21, 24, 32, 33, 41, 51)

(temps_f - 32) / 1.8
```
</details>

:::

<hr style="height:1pt; visibility:hidden;" />

### Other data structures in R

While vectors can be composed of one of several *data types*, they, in turn,
are one of several **data structures** that R uses.
Other important ones are^[Note, that technically, _factors_ are a data structure, but they are more intuitively thought of as a data type]:

- **`data.frame`** -- A rectangular data structure where each column can be a
  different data type.
- **`matrix`** -- A rectangular data structure of a single data type.
- **`list`** -- A very flexible data structure that we will not further discuss here.

<br>

## Data Frames

A data frame (formal object type: `data.frame`) is a rectangular data structure
in which:

  - Rows are observations and columns are variables.
  - Each column can be of a different type (numeric, character, etc.)
  - Since each column is a vector, all the values (cells) within a column are of the same type.
  - All columns have the same length.

![](img/vector-vs-df.png){fig-align="center" width="50%"}

### Create, write, and read a data frame

We can easily create a data frame by hand using the `data.frame()` function and
"`column_name = column_vector`" notation for each column:

```{r eval=TRUE, results='show'}
birds_df <- data.frame(species = birds,
                       wingspan = wingspans_cm,
                       size = sizes_cm,
                       n_eggs = c(2, 2, 7, 4)) 
```

```{r}
birds_df
```

Most often, however, you'll be reading your data frames from files.
And you'll also want to save your modified data frames.

So let's practice writing and reading a data frame to and from a "CSV" file ---
a plain-text, tabular file in which columns are delimited by commas ("Comma-Separated Values" file).

```{r, echo=FALSE}
dir.create("sandbox", showWarnings = FALSE)
```

```{r}
# Write a data frame to CSV format:
write.csv(x = birds_df, file = "sandbox/bird-data.csv", row.names = FALSE)
```

::: {.callout-note collapse="true"}
#### Curious what the file itself looks like? _(Click to expand)_

If you want to do the following yourself:
next to the R Console, there is tab called Terminal, which will open a Unix shell (!).
In there, type the following:

```bash
cat sandbox/bird-data.csv
```
```bash-out
"species","wingspan","size","n_eggs"
"hummingbird",11.8,7.62,2
"bald_eagle",203,90,2
"chickadee",18.2,13.1,7
"cardinal",27.9,21.8,4
```
:::

Now we read our data frame back in from the file:

```{r}
birds_df_2 <- read.csv("sandbox/bird-data.csv")

birds_df_2
```

<hr style="height:1pt; visibility:hidden;" />

### Inspecting a Data Frame

Use `str()` to look at the "structure" of the data ---
it tells us the number rows and columns, and for each column,
gives information about the data type and shows the first few values:

```{r str}
str(birds_df)
```

For larger data frames, the `head()` function, which will print the first 6 rows,
is also useful (but is of no real use for a tiny data frame like `birds_df`):

```{r summary}
head(birds_df)
```

Finally, in RStudio, you can open a data frame in a spreadsheet-like manner
by clicking on an object in the "Environment" pane, or equivalently, using `View()`: 
  
```{r View, eval=FALSE}
View(birds_df)
```

<hr style="height:1pt; visibility:hidden;" />

### Functions to get an overview of data frames

* **Size:**
  * `nrow()` -- Number of rows
  * `ncol()` -- Number of columns
  * `dim()` -- *Dim*ensions: c(number of rows, number of columns)
  * `length()` -- For a dataframe: number of columns. For a vector: number of elements.

* **Content:**
  * `head()` -- shows the first 6 rows
  * `tail()` -- shows the last 6 rows

* **Names:**
  * `names()` or `colnames()` -- column names
  * `rownames()` -- row names

* **Summary:**
  * `str()` -- structure of the object and information about the class, length and content of each column
  * `summary()` -- summary statistics for each column

<hr style="height:1pt; visibility:hidden;" />

::: exercise
#### {{< fa user-edit >}} Exercise: Cars

`mtcars` is an example data frame that is always available in R.

- Use `head()` to print the first 6 rows of the `mtcars` dataframe.

<details><summary>Click here for the solution</summary>

```{r}
head(mtcars)
```

</details>

- How many rows and columns does `mtcars` contain?

<details><summary>Click here for the solution</summary>

It contains 32 rows and 11 columns:

```{r}
dim(mtcars)
```

Or:

```{r}
nrow(mtcars)
ncol(mtcars)
```

</details>

- Get a vector with the column names of `mtcars`.

<details><summary>Click here for the solution</summary>

```{r}
colnames(mtcars)
```

</details>

:::

<br>

## Subsetting

### Basic subsetting of data frames and vectors

We can pull out parts of vectors and data frames using square brackets.

#### Vectors

For example, for vectors:

```{r}
# Remind ourselves what this vector contains
wingspans_cm
```

```{r}
# Get the first element
wingspan_cm[1]
```

```{r}
# Get the third element
wingspan_cm[3]
```

You can pull out larger "slices" from the vector by providing vectors of indices:

```{r}
# Get the first and the third element
wingspan_cm[c(1, 3)]
```

The `:` operator gives you a sequence of consecutive values,
which you can also using for slicing:

```{r}
# Get the second through the fourth element
wingspan_cm[2:4]
```

<hr style="height:1pt; visibility:hidden;" />

#### Data frames

To subset data frames, we need to provide two values:
row and column, with a comma between them.

For example, to get the element in the 1st row, 1st column:

```{r one_one_element}
birds_df[1, 1]
```

To get the element in the 2nd row, 3rd column:

```{r two_seven_element}
birds_df[2, 3]
```

To get the entire 2nd row, leave the column part blank:

```{r second_row}
birds_df[2, ]
```

And to extract the entire 3rd column, leave the row part blank:

```{r seventh_column}
birds_df[, 3]
```

To extract a column, you can also refer to it by name, in multiple ways:

```{r}
birds_df$size
```

```{r}
birds_df[, "size"]
```

<hr style="height:1pt; visibility:hidden;" />

::: exercise
#### {{< fa user-edit >}} Exercise: Subsetting

- Extract the 1st-3rd rows and the 4th colum from `birds_df`.

<details><summary>Click here for the solution</summary>

```{r}
birds_df[1:3, 4]
```

Or:

```{r}
birds_df[c(1, 2, 3), 4]
```
</details>

- Use the `$` notation to extract the `n_eggs` column from `birds_df`.

<details><summary>Click here for the solution</summary>

```{r}
birds_df$n_eggs
```
</details>
:::

<br>

## Miscellaneous

### Missing data

As R was designed to analyze datasets, it includes the concept of missing data
(which is uncommon in other programming languages).
Missing data are represented as `NA` (for "Not Available").

```{r create_vec_with_missing}
heights <- c(2, 4, 4, NA, 6)
```

When doing operations on numbers, most functions will return `NA` if the data
you are working with include missing values. It is a safer behavior as otherwise
you may overlook that you are dealing with missing data.
You can add the argument `na.rm=TRUE` to calculate the result while ignoring the missing values.

```{r na_rm}
mean(heights)

mean(heights, na.rm = TRUE)
```

<hr style="height:1pt; visibility:hidden;" />

### Packages

The functions that we have been using so far (and *many*, *many* more) are available
in any R session as soon as you start R (we refer to this functionality as *"base R"*).
However, when doing specialized analyses such as in microbiomics,
rather than coding up everything using the basic building blocks in R,
we can load add-on code that will allow us to use *"high-level"* functions
specifically geared towards the effective analyses of such data.

This type of add-on code is distributed in R *packages*.
The default *repository* for R packages is **CRAN**,
and you install CRAN packages with the `install.packages()` function:

```{r, eval=FALSE}
# Don't run this
install.packages("tidyverse")
```

If you’re doing bioinformatic analyses in R, as we will be doing,
you will encounter packages that are not on CRAN but are on "Bioconductor".
To install a package from Bioconductor, use the BiocManager package – for example:

```{r, eval=FALSE}
# Don't run this
install.packages("BiocManager")  # Install the BiocManager package
BiocManager::install("dada2")    # Install the dada2 package from Bioconductor
```

::: callout-warning
#### Installation issues at OSC
The installation of some packages is tricky at OSC nowadays,
and if you were to try the commands above, they would likely fail.
With a bit of extra effort, we can install these packages,
but during the workshop, we will be using a custom collection of pre-installed packages.
:::

<hr style="height:1pt; visibility:hidden;" />

### Saving your data

Some very brief notes on saving your data in R:

- We already saw the use of `write.csv()` to save data frames,
  and you can also use one of *readr*'s [writing     functions](https://readr.tidyverse.org/reference/write_delim.html).
  
- To save R objects "as is",
  which can be useful when you're working with complex S4 objects that may have
  taken a long time to generate, like a *phyloseq object*, you can use:
  
  ```{r, eval=FALSE}
  # Don't run this
  
  # Save an object:
  saveRDS(my_phyloseq_object, "my_phyloseq_object.RDS")
  
  # Load it again in a new R session:
  my_phyloseq_object <- readRDS("my_phyloseq_object.RDS")
  ```

- A general recommendation is to not rely on your R session to keep things around,
  especially "overnight". Devise your workflow such that you are always saving
  important objects and results outside of R,
  and can always use your R script to restart from where you left off.

::: {.callout-tip}
#### Optional: Change a setting to not let R save your Workspace

Along the line of the above, the default behavior of saving and restoring your "Workspace",
which are all the items (objects) that you create during an R session, is bad practice.
Instead, you should always recreate your environment from a script and/or saved files with individual pieces of data.

Change the following setting to prevent R from saving your Workspace whenever you close R:

1.  Click **`Tools`** (top bar, below your browser's address bar) \> **`Global Options`**
2.  In the pop-up window (stay on the `General` tab), change the settings under the "Workspace" heading to:

![](img/workspace.png){fig-align="center" width="45%"}

:::

<hr style="height:1pt; visibility:hidden;" />

### S4 Objects

While the object types we have discussed so far are so-called "*S3*" objects,
we will also be seeing "*S4*" objects in this workshop. 
S4 object are commonly used by bioinformatics packages, for instance *phyloseq*.

In a nutshell, S4 objects allow for complicated, multifaceted datasets
(e.g. multiple dataframes with and metadata) to be represented in a single object
in a standardized way.

Unlike S3 objects, S4 objects are usually not manipulated by simple assignment
with `<-`, but with specialized functions that are sure to adhere to the
strict object definitions.

<br>

## Where to go from here

This document only scratched the surface of R,
but it has hopefully provided a good starting point for working with R.

Here are some potential next steps:

1. Learn about plotting with *ggplot2*.
   Start with these two OSU Code Club sessions:
   - [ggplot part I](https://biodash.github.io/codeclub/s05e08_ggplot-1/)
   - [ggplot part II](https://biodash.github.io/codeclub/s05e09/)
   
2. Learn about data wrangling with tidyverse packages, especially *dplyr* and *tidyr*.
   Start with these two OSU Code Club sessions:
   - [Introduction to the tidyverse](https://osu-codeclub.github.io/posts/S07E06_tidy_01/)
   - [Tidyverse 2: More dplyr Data Wrangling](https://osu-codeclub.github.io/posts/S07E07_tidy_02/)

Both of those topics and some other material are also covered in this excellent
Carpentries workshop [R for Reproducible Scientific Analysis](https://swcarpentry.github.io/r-novice-gapminder/).

If you want to start with a book, I would recommend Wickham & Grolemund's
"R for Data Science", which is freely available on the web in a really nice format
[here](https://r4ds.hadley.nz/).

::: callout-warning
### Want to try the tidyverse (includes ggplot2) at OSC?
If you want to try using the tidyverse in RStudio at OSC now,
then load it as follows:

```{r, eval=FALSE}
.libPaths("/fs/ess/PAS0471/jelmer/R/metabar")
dyn.load("/fs/ess/PAS0471/jelmer/software/GLPK/lib/libglpk.so.40", local = FALSE)
library(tidyverse)
```

:::

<br>

## Bonus: conditional subsetting

Another common way of subsetting is by using a logical vector of the same length
as the original vector: any `TRUE` will select the element with the same index,
while `FALSE` will not:

```{r}
wingspans_cm

# This will extract the 1st and the 4th element
wingspans_cm[c(TRUE, FALSE, FALSE, TRUE)]
```

Typically, these logical vectors are not typed by hand, but are the output of
other functions or logical tests. For instance, if you wanted to select only the
values above 20:

```{r}
# This will return a logical vector with TRUE for indices that meet the condition
wingspans_cm > 20
```

```{r}
# We can use such a vector to select only the values above 20
wingspans_cm[wingspans_cm > 20]
```

<hr style="height:1pt; visibility:hidden;" />

#### `==` and `%in%`

You can test for equality with `==`:

```{r}
"chickadee" == "chickadee"

# Which element(s) of the birds vector equal "chickadee"
birds == "chickadee"

# Extract the element(s) of the birds vector that equal "chickadee"
birds[birds == "chickadee"]
```

If you want to use a **search vector with multiple items**, use `%in%` instead:

```{r}
# Which element(s) of the birds vector match any of the 3 birds on the right-hand side
birds %in% c("chickadee", "hummingbird", "shoebill")

# Extract those elements
birds[birds %in% c("chickadee", "hummingbird", "shoebill")] 
```

<hr style="height:1pt; visibility:hidden;" />

::: exercise
#### {{< fa user-edit >}} Exercise: Conditional subsetting

Given the following inhabitants of a house, and a list of species to keep:

```{r}
inhabitants <- c("rat", "rat", "dog", "mouse", "cat", "cat")
keep <- c("dog", "cat")
```

- What do you think the following would return? (Test it and see if you were right.)

  ```{r, eval=FALSE}
  inhabitants %in% keep
  ```
  
  ```{r, eval=FALSE}
  keep %in% inhabitants
  ```

<details><summary>Click here for the solution</summary>

```{r}
inhabitants %in% keep
```

```{r}
keep %in% inhabitants
```

</details>

- Extract the `dog`s and `cat`s from the inhabitants vector with logical subsetting.

<details><summary>Click here for the solution</summary>

```{r}
inhabitants[inhabitants %in% keep]
```

</details>

:::

<br>

### Attribution {-}

This material was modified after material from [The Carpentries](https://carpentries.org/),
especially from [this Data Carpentry workshop](http://uw-madison-aci.github.io/2016-06-01-uwmadison/)
and [this "R for Ecology" workshop](https://datacarpentry.org/R-ecology-lesson).
